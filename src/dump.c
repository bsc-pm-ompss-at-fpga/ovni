/* Copyright (c) 2021 Barcelona Supercomputing Center (BSC)
 * SPDX-License-Identifier: GPL-3.0-or-later */

#define _GNU_SOURCE

#include <dirent.h>
#include <errno.h>
#include <linux/limits.h>
#include <stdatomic.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

#include "emu.h"
#include "ovni.h"
#include "trace.h"

int filter_tid = -1;
char *tracedir;

static void
emit(struct ovni_stream *stream, struct ovni_ev *ev)
{
	uint64_t clock = ovni_ev_get_clock(ev);

	printf("%s.%d.%d  %ld  %c%c%c",
		stream->loom->hostname,
		stream->proc->pid,
		stream->thread->tid,
		clock,
		ev->header.model,
		ev->header.category,
		ev->header.value);

	int payloadsize = ovni_payload_size(ev);
	if (payloadsize > 0) {
		printf(" ");
		for (int i = 0; i < payloadsize; i++)
			printf(":%02x", ev->payload.u8[i]);
	}
	printf("\n");

	stream->lastclock = clock;
}


static void
dump_events(struct ovni_trace *trace)
{
	/* Load events */
	for (size_t i = 0; i < trace->nstreams; i++) {
		struct ovni_stream *stream = &trace->stream[i];

		/* It can be inactive if it has been disabled by the
		 * thread TID filter */
		if (stream->active)
			ovni_load_next_event(stream);
	}

	uint64_t lastclock = 0;

	while (1) {
		ssize_t f = -1;
		uint64_t minclock = 0;
		struct ovni_stream *stream = NULL;

		/* Select next event based on the clock */
		for (size_t i = 0; i < trace->nstreams; i++) {
			stream = &trace->stream[i];

			if (!stream->active)
				continue;

			struct ovni_ev *ev = stream->cur_ev;
			if (f < 0 || ovni_ev_get_clock(ev) < minclock) {
				f = i;
				minclock = ovni_ev_get_clock(ev);
			}
		}

		// fprintf(stderr, "f=%d minclock=%u\n", f, minclock);

		if (f < 0)
			break;

		stream = &trace->stream[f];

		if (lastclock > ovni_ev_get_clock(stream->cur_ev)) {
			fprintf(stdout, "warning: backwards jump in time %lu -> %lu\n",
				lastclock, ovni_ev_get_clock(stream->cur_ev));
		}

		/* Emit current event */
		emit(stream, stream->cur_ev);

		lastclock = ovni_ev_get_clock(stream->cur_ev);

		/* Read the next one */
		ovni_load_next_event(stream);

		/* Unset the index */
		f = -1;
		minclock = 0;
	}
}

static void
usage(void)
{
	err("Usage: ovnidump [-t TID] tracedir\n");
	err("\n");
	err("Dumps the events of the trace to the standard output.\n");
	err("\n");
	err("Options:\n");
	err("  -t TID      Only events from the given TID are shown\n");
	err("\n");
	err("  tracedir    The trace directory generated by ovni.\n");
	err("\n");

	exit(EXIT_FAILURE);
}

static void
parse_args(int argc, char *argv[])
{
	int opt;

	while ((opt = getopt(argc, argv, "t:")) != -1) {
		switch (opt) {
			case 't':
				filter_tid = atoi(optarg);
				break;
			default: /* '?' */
				usage();
		}
	}

	if (optind >= argc) {
		err("missing tracedir\n");
		usage();
	}

	tracedir = argv[optind];
}

int
main(int argc, char *argv[])
{
	parse_args(argc, argv);

	struct ovni_trace *trace = calloc(1, sizeof(struct ovni_trace));

	if (ovni_load_trace(trace, tracedir))
		return 1;

	if (ovni_load_streams(trace))
		return 1;

	if (filter_tid != -1) {
		for (size_t i = 0; i < trace->nstreams; i++) {
			struct ovni_stream *stream;
			stream = &trace->stream[i];
			if (stream->tid != filter_tid)
				stream->active = 0;
		}
	}

	dump_events(trace);

	ovni_free_streams(trace);

	free(trace);

	return 0;
}
